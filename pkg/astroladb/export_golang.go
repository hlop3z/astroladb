package astroladb

import (
	"bytes"
	"fmt"
	"strings"

	"github.com/hlop3z/astroladb/internal/ast"
	"github.com/hlop3z/astroladb/internal/strutil"
	"github.com/hlop3z/astroladb/internal/types"
)

// GoConverter converts types to Go.
type GoConverter struct {
	BaseConverter
}

// NewGoConverter creates a new Go converter.
func NewGoConverter() *GoConverter {
	return &GoConverter{
		BaseConverter: BaseConverter{
			TypeMap: map[string]string{
				"id":       "string",
				"uuid":     "string",
				"string":   "string",
				"text":     "string",
				"integer":  "int",
				"float":    "float64",
				"decimal":  "string",
				"boolean":  "bool",
				"date":     "time.Time",
				"time":     "time.Time",
				"datetime": "time.Time",
				"json":     "map[string]any",
				"base64":   "[]byte",
			},
			NullableFormat: "*%s",
		},
	}
}

// ConvertType converts a column definition to Go type.
func (c *GoConverter) ConvertType(col *ast.ColumnDef) string {
	// Get base type from TypeRegistry
	base := "string"
	if typeDef := types.Get(col.Type); typeDef != nil {
		base = typeDef.GoType
	}

	// Handle nullable types
	if col.Nullable {
		if base == "time.Time" {
			return "*time.Time"
		}
		if base == "[]byte" || strings.HasPrefix(base, "map[") {
			return base // Already reference types
		}
		return "*" + base
	}
	return base
}

// FormatName formats a name to Go conventions (PascalCase).
func (c *GoConverter) FormatName(name string) string {
	return strutil.ToPascalCase(name)
}

func exportGo(tables []*ast.TableDef, cfg *exportContext) ([]byte, error) {
	var buf bytes.Buffer

	// Check if any table uses time types
	needsTime := false
	for _, table := range tables {
		for _, col := range table.Columns {
			switch col.Type {
			case "date", "time", "datetime":
				needsTime = true
			}
		}
	}

	// Package declaration
	pkgName := "types"
	fmt.Fprintf(&buf, "// Package %s provides generated Go types from the database schema.\n", pkgName)
	fmt.Fprintf(&buf, "// Generated by: alab export --format go\n")
	fmt.Fprintf(&buf, "package %s\n\n", pkgName)
	if needsTime {
		fmt.Fprintf(&buf, "import \"time\"\n\n")
	}

	// Sort tables for deterministic output
	sortedTables := sortTablesByQualifiedName(tables)

	for _, table := range sortedTables {
		generateGoStruct(&buf, table, cfg)
		buf.WriteString("\n")
	}

	// Generate WithRelations variants if enabled
	if cfg.Relations {
		buf.WriteString("// WithRelations variants (includes relationship fields)\n\n")
		for _, table := range sortedTables {
			if table.Namespace == "" {
				continue
			}
			generateWithRelationsGo(&buf, table, sortedTables, cfg)
			buf.WriteString("\n")
		}
	}

	return buf.Bytes(), nil
}

// generateGoStruct generates a Go struct for a table.
func generateGoStruct(buf *bytes.Buffer, table *ast.TableDef, cfg *exportContext) {
	name := strutil.ToPascalCase(table.FullName())

	// Add struct comment
	if table.Docs != "" {
		fmt.Fprintf(buf, "// %s %s\n", name, table.Docs)
		if table.Deprecated != "" {
			fmt.Fprintf(buf, "// Deprecated: %s\n", table.Deprecated)
		}
	}

	fmt.Fprintf(buf, "type %s struct {\n", name)

	for _, col := range table.Columns {
		// Add field comment
		if col.Docs != "" {
			fmt.Fprintf(buf, "\t// %s\n", col.Docs)
		}

		fieldName := strutil.ToPascalCase(col.Name)
		goType := mapToGoType(col)

		// Generate JSON tag
		jsonTag := col.Name
		if col.Nullable {
			jsonTag += ",omitempty"
		}

		fmt.Fprintf(buf, "\t%s %s `json:\"%s\"`\n", fieldName, goType, jsonTag)
	}

	buf.WriteString("}\n")
}

// mapToGoType maps a column to its Go type.
func mapToGoType(col *ast.ColumnDef) string {
	return GetConverter(FormatGo).ConvertType(col)
}
