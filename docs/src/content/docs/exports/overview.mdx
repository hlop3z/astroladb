---
title: Export Overview
description: Generate type-safe code and API specifications from your schema
---

Astroladb exports your schema definitions to multiple languages and API
specifications, keeping your types synchronized across your entire stack.

**One schema, many outputs.** Define your data model once, then export it to whatever languages and frameworks your project uses.

## What Gets Exported

From a single schema definition, Astroladb generates:

- **Language Types**: Strongly-typed definitions for TypeScript, Go, Python, and Rust
- **API Specifications**: OpenAPI 3.0 and GraphQL schema definitions
- **Validation Rules**: Min/max constraints, patterns, and format hints
- **Documentation**: Comments and descriptions from `.docs()` modifiers

## Export Commands

```bash
# Export everything
alab export -f all

# Export specific format
alab export -f typescript
alab export -f openapi

# Merge into single files per format
alab export -f all --merge
```

## Supported Formats

| Format       | Output                       | Use Case                    |
| ------------ | ---------------------------- | --------------------------- |
| `typescript` | Interfaces, type definitions | Frontend, Node.js backend   |
| `go`         | Structs with JSON tags       | Go APIs and services        |
| `python`     | Dataclasses with type hints  | Python APIs, data science   |
| `rust`       | Structs with Serde derives   | Rust services               |
| `openapi`    | OpenAPI 3.0 specification    | API documentation, codegen  |
| `graphql`    | GraphQL schema definitions   | GraphQL APIs                |

### Output Directory

By default, exports are written to `./generated/<format>/`:

```
generated/
├── typescript/
│   ├── auth/
│   │   └── user.ts
│   └── blog/
│       └── post.ts
├── go/
│   ├── auth/
│   │   └── user.go
│   └── blog/
│       └── post.go
├── openapi/
│   └── openapi.yaml
└── graphql/
    └── schema.graphql
```

## Export Behavior

### What's Included

- All column fields with their types
- Validation constraints (min, max, pattern)
- Format hints (email, uri, etc.)
- Documentation from `.docs()` modifiers
- Enum values
- Relationship references

### What's Excluded

- Columns marked with `x-hidden` (e.g., `col.password_hash()`)
- Internal metadata columns
- Migration-specific configurations

### Type Mapping

| Schema Type        | TypeScript    | Go            | Python       | Rust         |
| ------------------ | ------------- | ------------- | ------------ | ------------ |
| `col.id()`         | `string`      | `string`      | `str`        | `String`     |
| `col.string()`     | `string`      | `string`      | `str`        | `String`     |
| `col.text()`       | `string`      | `string`      | `str`        | `String`     |
| `col.integer()`    | `number`      | `int`         | `int`        | `i32`        |
| `col.float()`      | `number`      | `float64`     | `float`      | `f64`        |
| `col.decimal()`    | `number`      | `float64`     | `Decimal`    | `f64`        |
| `col.boolean()`    | `boolean`     | `bool`        | `bool`       | `bool`       |
| `col.datetime()`   | `Date`        | `time.Time`   | `datetime`   | `DateTime`   |
| `col.date()`       | `Date`        | `time.Time`   | `date`       | `NaiveDate`  |
| `col.json()`       | `any`         | `interface{}` | `dict`       | `Value`      |
| `col.enum([...])`  | `union type`  | `string`      | `Literal`    | `enum`       |

### Nullable Fields

Optional columns (`.optional()`) are mapped to nullable types:

- TypeScript: `string | null`
- Go: `*string` (pointer)
- Python: `str | None` or `Optional[str]`
- Rust: `Option<String>`

## Example Export

Given this schema:

```js
// schemas/blog/post.js
export default table({
  id: col.id(),
  title: col.title(),
  content: col.body(),
  published: col.flag(),
  author: col.belongs_to("auth.user"),
}).timestamps();
```

### TypeScript Output

```typescript
// generated/typescript/blog/post.ts
export interface Post {
  id: string;
  title: string;
  content: string;
  published: boolean;
  author_id: string;
  created_at: Date;
  updated_at: Date;
}
```

### Go Output

```go
// generated/go/blog/post.go
package blog

import "time"

type Post struct {
    ID        string    `json:"id"`
    Title     string    `json:"title"`
    Content   string    `json:"content"`
    Published bool      `json:"published"`
    AuthorID  string    `json:"author_id"`
    CreatedAt time.Time `json:"created_at"`
    UpdatedAt time.Time `json:"updated_at"`
}
```

### Python Output

```python
# generated/python/blog/post.py
from dataclasses import dataclass
from datetime import datetime

@dataclass
class Post:
    id: str
    title: str
    content: str
    published: bool
    author_id: str
    created_at: datetime
    updated_at: datetime
```

## Workflow Integration

Exports are designed to integrate into your development workflow:

1. **Define schema** in `schemas/`
2. **Run migrations** with `alab migrate`
3. **Export types** with `alab export -f all`
4. **Import in code** and get full type safety

### CI/CD Example

```bash
#!/bin/bash
# In your CI pipeline

# Apply migrations
alab migrate

# Export types for all languages
alab export -f all

# Commit generated files
git add generated/
git commit -m "Update generated types"
```

### Watch Mode (Future)

While not currently implemented, future versions may support watch mode:

```bash
# Watch for schema changes and auto-export (future feature)
alab watch
```

## Best Practices

1. **Commit generated files** - Treat them as build artifacts for code review
2. **Use separate branches** - Export types in feature branches alongside schema changes
3. **Version control exports** - Track changes to understand API evolution
4. **Document breaking changes** - Use semantic versioning when types change
5. **Validate before deploy** - Run `alab check` to validate schemas before exporting
