package engine

import (
	"fmt"
	"strings"

	"github.com/hlop3z/astroladb/internal/ast"
)

// PhaseType indicates the type of migration phase.
type PhaseType int

const (
	// DDL phase: CREATE TABLE, ALTER TABLE, DROP, ADD COLUMN (runs in transaction)
	DDL PhaseType = iota
	// Index phase: CREATE INDEX CONCURRENTLY (runs outside transaction)
	Index
	// Data phase: Backfills, large updates (runs in transaction with batching)
	Data
)

// String returns the string representation of the phase type.
func (p PhaseType) String() string {
	switch p {
	case DDL:
		return "DDL"
	case Index:
		return "Index"
	case Data:
		return "Data"
	default:
		return "Unknown"
	}
}

// Phase represents a single execution phase of a migration.
type Phase struct {
	// Type indicates what kind of operations this phase contains
	Type PhaseType

	// Ops are the operations to execute in this phase
	Ops []ast.Operation

	// InTransaction indicates whether this phase should run in a transaction
	InTransaction bool

	// Batched indicates whether operations should be batched (for large updates)
	Batched bool
}

// SplitIntoPhases analyzes migration operations and splits them into execution phases.
// Returns phases in execution order: DDL → Index → Data
// Empty phases are omitted from the result.
func SplitIntoPhases(ops []ast.Operation) []Phase {
	var ddlOps []ast.Operation
	var indexOps []ast.Operation
	var dataOps []ast.Operation

	for _, op := range ops {
		switch op.(type) {
		case *ast.CreateTable, *ast.DropTable, *ast.RenameTable,
			*ast.AddColumn, *ast.DropColumn, *ast.RenameColumn,
			*ast.AlterColumn, *ast.AddForeignKey, *ast.DropForeignKey,
			*ast.AddCheck, *ast.DropCheck, *ast.RawSQL:
			// DDL operations go to Phase 1
			ddlOps = append(ddlOps, op)

			// Extract indexes from table/column definitions
			if indexes := extractIndexes(op); len(indexes) > 0 {
				indexOps = append(indexOps, indexes...)
			}

		case *ast.CreateIndex:
			// Index operations go to Phase 2
			indexOps = append(indexOps, op)

		case *ast.DropIndex:
			// Drop index is DDL (can run in transaction)
			ddlOps = append(ddlOps, op)
		}

		// Check if operation has backfill data (added via .backfill() in DSL)
		if backfill := extractBackfill(op); backfill != nil {
			dataOps = append(dataOps, backfill)
		}
	}

	// Build phases (only include non-empty phases)
	var phases []Phase

	if len(ddlOps) > 0 {
		phases = append(phases, Phase{
			Type:          DDL,
			Ops:           ddlOps,
			InTransaction: true,
			Batched:       false,
		})
	}

	if len(indexOps) > 0 {
		phases = append(phases, Phase{
			Type:          Index,
			Ops:           indexOps,
			InTransaction: false, // CREATE INDEX CONCURRENTLY must run outside transaction
			Batched:       false,
		})
	}

	if len(dataOps) > 0 {
		phases = append(phases, Phase{
			Type:          Data,
			Ops:           dataOps,
			InTransaction: true,
			Batched:       true, // Data operations are always batched
		})
	}

	return phases
}

// extractIndexes extracts index operations from table/column definitions.
// Returns CREATE INDEX operations for:
// - Columns with .unique() modifier
// - Columns with .index() modifier
func extractIndexes(op ast.Operation) []ast.Operation {
	var indexes []ast.Operation

	switch v := op.(type) {
	case *ast.CreateTable:
		// Extract indexes from table definition
		for _, idx := range v.Indexes {
			indexes = append(indexes, &ast.CreateIndex{
				TableRef: ast.TableRef{
					Namespace: v.Namespace,
					Table_:    v.Name,
				},
				Name:    idx.Name,
				Columns: idx.Columns,
				Unique:  idx.Unique,
			})
		}

		// Extract indexes from column definitions (unique, index)
		for _, col := range v.Columns {
			if col.Unique {
				// .unique() creates a UNIQUE INDEX
				indexes = append(indexes, &ast.CreateIndex{
					TableRef: ast.TableRef{
						Namespace: v.Namespace,
						Table_:    v.Name,
					},
					Name:    "", // Auto-generated by dialect
					Columns: []string{col.Name},
					Unique:  true,
				})
			}
			if col.Index {
				// .index() creates a non-unique INDEX
				indexes = append(indexes, &ast.CreateIndex{
					TableRef: ast.TableRef{
						Namespace: v.Namespace,
						Table_:    v.Name,
					},
					Name:    "", // Auto-generated by dialect
					Columns: []string{col.Name},
					Unique:  false,
				})
			}
		}

	case *ast.AddColumn:
		// Check if column has .unique() or .index() modifier
		if v.Column != nil && v.Column.Unique {
			indexes = append(indexes, &ast.CreateIndex{
				TableRef: v.TableRef,
				Name:     "", // Auto-generated
				Columns:  []string{v.Column.Name},
				Unique:   true,
			})
		}
		if v.Column != nil && v.Column.Index {
			indexes = append(indexes, &ast.CreateIndex{
				TableRef: v.TableRef,
				Name:     "", // Auto-generated
				Columns:  []string{v.Column.Name},
				Unique:   false,
			})
		}
	}

	return indexes
}

// extractBackfill extracts backfill operations from column definitions.
// Returns a backfill operation if the column has .backfill() modifier.
func extractBackfill(op ast.Operation) ast.Operation {
	// Check if operation is AddColumn with backfill
	addCol, ok := op.(*ast.AddColumn)
	if !ok || addCol.Column == nil || !addCol.Column.HasBackfill() {
		return nil
	}

	// Extract table and column info
	tableName := addCol.Table()
	columnName := addCol.Column.Name
	backfillValue := addCol.Column.Backfill

	// Format the backfill value for SQL
	// Note: GenerateBatchedUpdate produces PostgreSQL-specific PL/pgSQL (DO $$ blocks),
	// so we use the Postgres expression from per-dialect SQLExpr.
	var valueSQL string
	if sqlExpr, ok := backfillValue.(*ast.SQLExpr); ok {
		valueSQL = sqlExpr.Postgres
	} else {
		// Literal value - needs proper SQL formatting
		valueSQL = formatBackfillValue(backfillValue)
	}

	// WHERE clause: only update rows where column is NULL
	// (prevents re-backfilling if migration is re-run)
	whereClause := columnName + " IS NULL"

	// Generate batched UPDATE SQL
	sql := GenerateBatchedUpdate(tableName, columnName, valueSQL, whereClause)

	// Return as RawSQL operation
	return &ast.RawSQL{
		SQL: sql,
	}
}

// formatBackfillValue formats a backfill value for SQL.
func formatBackfillValue(val any) string {
	switch v := val.(type) {
	case string:
		// Escape single quotes
		return "'" + escapeSQL(v) + "'"
	case bool:
		if v {
			return "TRUE"
		}
		return "FALSE"
	case int, int32, int64:
		return fmt.Sprintf("%d", v)
	case float32, float64:
		return fmt.Sprintf("%v", v)
	case nil:
		return "NULL"
	default:
		// Fallback: treat as string and escape
		return "'" + escapeSQL(fmt.Sprintf("%v", v)) + "'"
	}
}

// escapeSQL escapes single quotes in SQL strings.
func escapeSQL(s string) string {
	return strings.ReplaceAll(s, "'", "''")
}
