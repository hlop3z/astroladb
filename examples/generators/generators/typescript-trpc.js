// TypeScript tRPC Code Generator (v2 - Clean Templates)
// Generates Zod schemas and tRPC routers from your alab schema.
//
// Usage:
//   alab gen run generators/typescript-trpc -o ./generated

export default gen((schema) => {
  const files = {};

  // ─── Helpers ───────────────────────────────────────────────

  const capitalize = (s) => s.charAt(0).toUpperCase() + s.slice(1);
  const pascalCase = (s) => s.split("_").map(capitalize).join("");
  const camelCase = (s) => {
    const pascal = pascalCase(s);
    return pascal.charAt(0).toLowerCase() + pascal.slice(1);
  };

  const TYPE_MAP = {
    uuid: "z.string().uuid()",
    string: "z.string()",
    text: "z.string()",
    integer: "z.number().int()",
    float: "z.number()",
    boolean: "z.boolean()",
    date: "z.date()",
    time: "z.string()",
    datetime: "z.date()",
    decimal: "z.number()",
    json: "z.record(z.any())",
    base64: "z.string()",
  };

  const zodType = (col) => {
    if (col.type === "enum" && col.enum) {
      return `z.enum([${col.enum.map((v) => `"${v}"`).join(", ")}])`;
    }
    let type = TYPE_MAP[col.type] || "z.any()";
    if (col.nullable) type += ".nullable()";
    if (col.default !== undefined && typeof col.default !== "object") {
      const def = typeof col.default === "string"
        ? `"${col.default}"`
        : col.default;
      type += `.default(${def})`;
    }
    return type;
  };

  // ─── Templates ─────────────────────────────────────────────

  const schemaFile = (tables) => {
    const schemas = tables.map((table) => {
      const cls = pascalCase(table.name);
      const camel = camelCase(table.name);
      const fields = table.columns
        .filter((c) => !["id", "created_at", "updated_at"].includes(c.name))
        .map((col) => `  ${col.name}: ${zodType(col)},`)
        .join("\n");

      return `
// ${table.name} schemas
export const ${camel}BaseSchema = z.object({
${fields || "  // No user-defined fields"}
});

export const ${camel}Schema = ${camel}BaseSchema.extend({
  id: z.string().uuid(),
${table.timestamps ? "  created_at: z.date(),\n  updated_at: z.date()," : ""}
});

export type ${cls}Base = z.infer<typeof ${camel}BaseSchema>;
export type ${cls} = z.infer<typeof ${camel}Schema>;
`.trim();
    }).join("\n\n");

    return `import { z } from "zod";\n\n${schemas}\n`;
  };

  const routerFile = (ns, tables) => {
    const imports = tables
      .map((t) => `  ${pascalCase(t.name)},\n  ${pascalCase(t.name)}Base,\n  ${camelCase(t.name)}Schema,\n  ${camelCase(t.name)}BaseSchema,`)
      .join("\n");

    const routers = tables.map((table) => {
      const camel = camelCase(table.name);
      return `
export const ${camel}Router = router({
  list: publicProcedure
    .query(async () => {
      throw new TRPCError({ code: "NOT_IMPLEMENTED" });
    }),

  get: publicProcedure
    .input(z.object({ id: z.string().uuid() }))
    .query(async ({ input }) => {
      throw new TRPCError({ code: "NOT_IMPLEMENTED" });
    }),

  create: publicProcedure
    .input(${camel}BaseSchema)
    .mutation(async ({ input }) => {
      throw new TRPCError({ code: "NOT_IMPLEMENTED" });
    }),

  update: publicProcedure
    .input(z.object({ id: z.string().uuid(), data: ${camel}BaseSchema }))
    .mutation(async ({ input }) => {
      throw new TRPCError({ code: "NOT_IMPLEMENTED" });
    }),

  delete: publicProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ input }) => {
      throw new TRPCError({ code: "NOT_IMPLEMENTED" });
    }),
});
`.trim();
    }).join("\n\n");

    return `
import { z } from "zod";
import { initTRPC, TRPCError } from "@trpc/server";

import {
${imports}
} from "./schemas";

const t = initTRPC.create();
const router = t.router;
const publicProcedure = t.procedure;

${routers}
`.trim() + "\n";
  };

  const appRouterFile = (namespaces, tables) => {
    const imports = [];
    const routers = [];

    for (const ns of namespaces) {
      for (const table of tables[ns]) {
        const camel = camelCase(table.name);
        imports.push(`import { ${camel}Router } from "./${ns}/routers";`);
        routers.push(`  ${camel}: ${camel}Router,`);
      }
    }

    return `
import { initTRPC } from "@trpc/server";

${imports.join("\n")}

const t = initTRPC.create();

export const appRouter = t.router({
${routers.join("\n")}
});

export type AppRouter = typeof appRouter;
`.trim() + "\n";
  };

  const serverFile = () => `
/**
 * tRPC Server (generated by alab)
 *
 * Run:
 *   npm install @trpc/server @trpc/client zod
 *   npm install -D tsx
 *   npx tsx server.ts
 */

import { createHTTPServer } from "@trpc/server/adapters/standalone";
import { appRouter } from "./app-router";

const server = createHTTPServer({
  router: appRouter,
  createContext() {
    return {};
  },
});

server.listen(3000);
console.log("✓ tRPC server running on http://localhost:3000");
`.trim() + "\n";

  const readmeFile = () => `
# tRPC API (generated by alab)

## Setup

\`\`\`bash
npm install @trpc/server @trpc/client zod
npm install -D tsx typescript @types/node
\`\`\`

## Run Server

\`\`\`bash
npx tsx server.ts
\`\`\`

## Example Client

\`\`\`typescript
import { createTRPCClient, httpBatchLink } from "@trpc/client";
import type { AppRouter } from "./app-router";

const client = createTRPCClient<AppRouter>({
  links: [httpBatchLink({ url: "http://localhost:3000" })],
});

// Usage
const items = await client.users.list.query();
const user = await client.users.get.query({ id: "uuid" });
const created = await client.users.create.mutate({ name: "Alice" });
\`\`\`
`.trim() + "\n";

  // ─── Generate ──────────────────────────────────────────────

  for (const [ns, tables] of Object.entries(schema.models)) {
    files[`${ns}/schemas.ts`] = schemaFile(tables);
    files[`${ns}/routers.ts`] = routerFile(ns, tables);
  }

  files["app-router.ts"] = appRouterFile(Object.keys(schema.models), schema.models);
  files["server.ts"] = serverFile();
  files["README.md"] = readmeFile();

  return render(files);
});
