// Rust Axum Code Generator (v2 - Clean Templates)
// Generates Serde models and Axum handlers from your alab schema.
//
// Usage:
//   alab gen run generators/rust-axum -o ./generated

export default gen((schema) => {
  const files = {};

  // ─── Helpers ───────────────────────────────────────────────

  const capitalize = (s) => s.charAt(0).toUpperCase() + s.slice(1);
  const pascalCase = (s) => s.split("_").map(capitalize).join("");

  const TYPE_MAP = {
    uuid: "Uuid",
    string: "String",
    text: "String",
    integer: "i64",
    float: "f64",
    boolean: "bool",
    date: "NaiveDate",
    time: "NaiveTime",
    datetime: "DateTime<Utc>",
    decimal: "Decimal",
    json: "serde_json::Value",
    base64: "String",
  };

  const rustType = (col) => {
    const typ = TYPE_MAP[col.type] || "String";
    return col.nullable ? `Option<${typ}>` : typ;
  };

  const rustField = (col) =>
    `    pub ${col.name}: ${rustType(col)},`;

  // ─── Templates ─────────────────────────────────────────────

  const modelsFile = (tables) => {
    const models = tables.map((table) => {
      const cls = pascalCase(table.name);
      const fields = table.columns
        .filter((c) => !["id", "created_at", "updated_at"].includes(c.name))
        .map(rustField);

      const baseFields = fields.length > 0
        ? fields.join("\n")
        : "    // No user-defined fields";

      const fullFields = [
        `    pub id: Uuid,`,
        ...fields,
        table.timestamps ? `    pub created_at: DateTime<Utc>,\n    pub updated_at: DateTime<Utc>,` : ""
      ].filter(Boolean).join("\n");

      return `
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ${cls}Base {
${baseFields}
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ${cls} {
${fullFields}
}
`.trim();
    }).join("\n\n");

    return `
use chrono::{DateTime, NaiveDate, NaiveTime, Utc};
use rust_decimal::Decimal;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

${models}
`.trim() + "\n";
  };

  const handlersFile = (ns, tables) => {
    const imports = tables
      .map((t) => `${pascalCase(t.name)}, ${pascalCase(t.name)}Base`)
      .join(", ");

    const handlers = tables.map((table) => {
      const cls = pascalCase(table.name);
      const name = table.name;

      const listHandler = `
pub async fn list_${name}(
    State(_state): State<AppState>,
) -> impl IntoResponse {
    (StatusCode::NOT_IMPLEMENTED, Json("not implemented"))
}`;

      const getHandler = `
pub async fn get_${name}(
    State(_state): State<AppState>,
    Path(id): Path<Uuid>,
) -> impl IntoResponse {
    (StatusCode::NOT_IMPLEMENTED, Json("not implemented"))
}`;

      const createHandler = `
pub async fn create_${name}(
    State(_state): State<AppState>,
    Json(_body): Json<${cls}Base>,
) -> impl IntoResponse {
    (StatusCode::NOT_IMPLEMENTED, Json("not implemented"))
}`;

      const updateHandler = `
pub async fn update_${name}(
    State(_state): State<AppState>,
    Path(id): Path<Uuid>,
    Json(_body): Json<${cls}Base>,
) -> impl IntoResponse {
    (StatusCode::NOT_IMPLEMENTED, Json("not implemented"))
}`;

      const deleteHandler = `
pub async fn delete_${name}(
    State(_state): State<AppState>,
    Path(id): Path<Uuid>,
) -> impl IntoResponse {
    StatusCode::NOT_IMPLEMENTED
}`;

      return `
// ${name} handlers
${listHandler}

${getHandler}

${createHandler}

${updateHandler}

${deleteHandler}
`.trim();
    }).join("\n\n");

    return `
use axum::{
    extract::{Path, State},
    http::StatusCode,
    response::IntoResponse,
    Json,
};
use uuid::Uuid;

use crate::models::{${imports}};

type AppState = ();

${handlers}
`.trim() + "\n";
  };

  const routesFile = (ns, tables) => {
    const routes = tables.map((table) => {
      const name = table.name;
      const slug = name.replace(/_/g, "-");
      return `        .route("/${slug}", get(list_${name}).post(create_${name}))
        .route("/${slug}/:id", get(get_${name}).patch(update_${name}).delete(delete_${name}))`;
    }).join("\n");

    return `
use axum::{routing::{delete, get, patch, post}, Router};

use crate::${ns}::handlers::*;

pub fn ${ns}_routes() -> Router {
    Router::new()
${routes}
}
`.trim() + "\n";
  };

  const mainFile = (namespaces) => {
    const mods = namespaces.map((ns) => `mod ${ns};`).join("\n");
    const uses = namespaces.map((ns) => `use ${ns}::routes::${ns}_routes;`).join("\n");
    const routes = namespaces
      .map((ns) => `        .nest("/${ns}", ${ns}_routes())`)
      .join("\n");

    return `
//! Axum API (generated by alab)
//!
//! Run:
//!   cargo add axum tokio serde serde_json uuid chrono rust_decimal
//!   cargo add -F tokio/full -F uuid/v4 -F uuid/serde
//!   cargo run

mod models;
${mods}

${uses}

#[tokio::main]
async fn main() {
    let app = axum::Router::new()
${routes}
        .route("/", axum::routing::get(|| async { "Alab Generated API" }));

    let listener = tokio::net::TcpListener::bind("127.0.0.1:3000")
        .await
        .unwrap();

    println!("✓ Axum server running on http://127.0.0.1:3000");
    axum::serve(listener, app).await.unwrap();
}
`.trim() + "\n";
  };

  const cargoToml = () => `
[package]
name = "alab-api"
version = "0.1.0"
edition = "2021"

[dependencies]
axum = "0.7"
tokio = { version = "1", features = ["full"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
uuid = { version = "1", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }
rust_decimal = "1"
`.trim() + "\n";

  // ─── Generate ──────────────────────────────────────────────

  files["src/models.rs"] = modelsFile(Object.values(schema.models).flat());

  for (const [ns, tables] of Object.entries(schema.models)) {
    files[`src/${ns}/mod.rs`] = "pub mod handlers;\npub mod routes;\n";
    files[`src/${ns}/handlers.rs`] = handlersFile(ns, tables);
    files[`src/${ns}/routes.rs`] = routesFile(ns, tables);
  }

  files["src/main.rs"] = mainFile(Object.keys(schema.models));
  files["Cargo.toml"] = cargoToml();

  return render(files);
});
